# passion

passionはゲーム開発で使用するc++ライクな言語としてデザインされたc++より少しだけ書きやすいプログラム言語です。

また、passionはc/c++を置き換えることを目的としているのではなく、c/c++と連携することで最大限に活かすことができるプログラム言語です。

## passionの歴史

passionは元々ゲーム開発用に開発したJavaライクな言語があり、それをベースに進化してきた言語です。

一番最初の実行環境（仮想マシン）はフューチャーフォン上で動くJavaで実装されておりプログラムサイズは数十キロバイトで実行速度もかなり遅いものでした。それでもロールプレイングゲームの中でミニゲームを動かしたりする必要があったため本格的なプログラムがかける必要があったのです。

その時のプログラムは次のような感じになっていました。感の良い人は動的型付け言語であることに気が付くかもしれません。現在のpassionとりもスクリプト言語らしさを感じます。

```cpp
class MyClass
{
    value1, value2;

    f1(arg1, arg2)
    {
        var  v = arg1 + arg2;
        return new YouClass(v);
    }
};
```

しかしゲームのイベントスクリプトを書くのはプログラムが分からないスタッフがほとんどです。そこでさらにプリプロセッサを用いて次のような感じで書くことができるようになっていました。これならプログラマ以外でも書けそうですね。また、これを実現させるためにプリプロセッサマクロも引数の数違いでオーバーロードできるように作りました。

```cpp
// Event0001_0003.psc
#include <Event.h>
EVENT_BEGIN
MESSAGE_WINDOW("Jon", "Hello")   // JonがHelloと言う
MESSAGE_WINDOW("...Oh my god!")  // キャラクターはJonのままでセリフだけ変える。
EVENT_END
```

```cpp
// Event.h
// これはプログラマが用意する。
#define EVENT_BEGIN \
    class __BASEFILENAME__ : EventSystemBase {

#define EVENT_END }

#define MESSAGE_WINDOW(_msg) \
    this.set_message(_msg);\
    this.wait_for_input();

#define MESSAGE_WINDOW(_char, _msg) \
    this.change_character(_char);\
    this.set_message(_msg);\
    this.wait_for_input();
```

この作りは実際うまくいきました。最終的には戦闘シーンでのダメージ計算などもスクリプト化しました。このダメージ計算スクリプトはサーバーからアプリにダウンロードされいつでもゲームバランスを修正することができるようになっていました。

```cpp
// ダメージ計算を行うスクリプト
class DamageCalculator
{
    attack(atacker, defender)
    {
        return (atacker.atk + atacker.weapon().atk) - (defender.def + defender.armor().def);
    }
}
```

passionの元となった言語はこの作りで数タイトルのゲーム開発に使われました。

旧言語でのゲーム開発はそれはそれで良かったのですがふたつほど不満が出てきました。それは「変数の型が分からない」「動作速度がいまいち遅い」という事です。これはつまり「動的型付けが問題」というところに帰結しました。

また旧言語は企業に所属していた時に作ったので権利的なことを考えるとオープンソースにするのは色々と問題がありました。そこでこれらの問題を解決すべく経験だけを活かし新規に作り直し始めたのがpassionです。passionの開発の出だしは悪くはありませんでしたが、その後仕事が忙しかったりなんだりと色々あり、開発は長いこと停滞し、いつしかその存在を忘れていました。

そして会社を辞めフリーランスになり、新卒以下の収入という収入が少ないというデメリットの代わりに自由な時間を手に入れようやく本格的な開発に着手することができるようになりました。

## passionのコンセプト

passionは元々ゲームのイベントを開発するためのスクリプト言語というのがコンセプトのベースになっています。しかしオープンソース全盛期のこの時代、せっかくオープンソースにするならゲームに組み込む以外にもpassion単体でいろいろ出来たほうが楽しいのではないか？と考え、いろいろと考え直しながら設計しています。

そして以下のコンセプトを掲げることにしました。

1. c/c++ライクな構文を持つ

2. 静的片付けでなるべくコンパイル時に解決する

3. c/c++と連携しやすい

4. 直感的な構文になるのであればc/c++と異なってもよい


また、c/c++の哲学に倣いpassionも哲学を参考にしてデザインしています。

	・passionはプログラマが間違っている可能性があったとしてもプログラマに選択の余地を与える。
	・passionは直接的かつ包括的に複数のプログラミングスタイル（手続き型プログラミング、抽象化、オブジェクト指向、ジェネリックプログラミング）をサポートする。
	・passionは利用しない機能については可能な限りオーバーヘッドが生じない（ゼロオーバーヘッドの原則、ネイティブコンパイル時）。
	・passionは高級な実行環境を必要としない（ネイティブコンパイル時）。
	・passionはプラットフォームに固有な機能や汎用的でない機能でも広く使われている機能であれば取り入れる。
	・passionは少ない手間でC++言語との互換性を持ち、習得が安易である。
	・passionはプログラマがサブプログラマに制限を付けたいときに制限をかけられる。

## 動作可能環境

c++17でプログラムをコンパイルし実行できる環境ならばpassionは実行できるはずです。Intel x86（とその互換ＣＰＵ）とARM互換の３２ビット以上のレジスタ幅を持つＣＰＵであれば動作するはずです。

### 対応ＣＰＵ

Intel x86とARMをベースとした３２ビット以上のCPUをメインに開発しています。その他のＣＰＵでもおそらく動作すると思いますがなかなかテスト環境が用意できないので公式には非サポートです。

## passionにおけるデータ型

passionのプログラムでは整数型として int, int8_t, int16_t, int32_t, int64_t をサポートしています。また、浮動小数型はfloat, doubleをサポートしています。

### int型

c/c++の規格上はint型はビット幅は絶対的な大きさは定められていません。６４ビット環境向けにコンパイルしてもデータモデル（※１）によって３２ビットだったり６４ビットだったりします。

passionではint型は常に実行環境におけるアドレス幅と同じで、データモデルで言うとILP32やILP64に相当します。別の言い方をするとpassionのintはc/c++におけるintptr_tと同じ扱いです。つまりpassionでは常にsizeof(int) == sizeof(void*) が成立します。

※１）LP64やILP64などで検索すると分かりやすいです

### コンパイル時のint型とアドレス型の扱い

int型やアドレス型（ポインタ型）はコンパイル直後はそのサイズを確定できないため、実行環境に合わせてサイズが変わるデータ型という特殊なデータ型であることを記録します。このデータ型はバイトコードをメモリに展開し実行するための前処理を行う際にバイトコードを修正します。

### 不動少数型

浮動小数型(float, double)を用いる場合はターゲットとなる環境が ISO/ICE559(IEE754)に準拠している必要があります（メジャーな汎用ＣＰＵはIEEE754を採用しているので問題になることはないはずです）。

## データ型一覧

|              | バイト長       | 補足                                            |
| ------------ | -------------- | ----------------------------------------------- |
| int          | 実行環境依存   | ＣＰＵの汎用レジスタと同一サイズ。              |
| TYPE*, TYPE& | == sizeof(int) | 書式上の違いのみで実行時は同一の扱い。          |
| TYPE^        | == sizeof(int) | 参照カウンタ付きのポインタ。                    |
| TYPE[]       | == sizeof(int) | 配列。実行時はTYPE^と同じ扱い。                 |
| string       | == sizeof(int) | 内部的には常にstring == string^として扱われる。 |
| char         | 1              |                                                 |
| int8_t       | 1              |                                                 |
| int16_t      | 2              |                                                 |
| int32_t      | 4              |                                                 |
| int64_t      | 8              |                                                 |
| float        | 4              | IEE 754                                         |
| double       | 8              | IEE 754                                         |

# リテラル

リテラルとは、値を直接に表すプログラム要素です。passionでは整数型、浮動小数点型、ブール型、ポインタ型があります。また、文字列はstring型の特殊なリテラルとして扱われます。

## string型

文字列リテラルはstring型の動的オブジェクトとして扱われます。string型は実際には psn::string^ のエイリアスとなっており、プログラム内で直接扱うことのできる値ではありませんがプログラムを組むうえで文字列の利用頻度は高いためpassionでは直接扱えるようになっています。

## 整数型、浮動小数点型、ブール型

整数型や浮動小数点型などstring型以外のリテラルはオブジェクトではありませんが、プログラムコード上ではあたかもオブジェクトのように扱われます。そのため、整数型などのデータにもメンバ関数が存在します。

```c++
string a = 1.to_string();  // a is "1"
string b = "*Hello*".substr(1, 5); // b is "Hello"
```

## ガベージコレクションポインタ型

GCポインタ型はc/c++から見ると少々特殊なポインタです。passionではclassキーワードで宣言されたクラスをnew演算子でインスタンス化するとき、GCポインタ型のポインタを返します。GCポインタ型は通常のポインタが *宣言子を使うのに対してGCポインタは^宣言子を使用します。

passionではインスタンス化されたオブジェクトは必ず参照カウンタを持っており、オブジェクトが何か所から使用されているのかをカウントしています。GCポインタ型の変数が破棄されるとき、参照していたオブジェクトのカウントを減少させカウントが０になると自動的にオブジェクトを破棄します。これにより、プログラマはオブジェクトの寿命を自分で管理する必要なく安全にリソースを解放できます。

また、参照カウンタの増減はコンパイラによって最低限に抑えられますので少ないオーバーヘッドで実行することができます。また、GCポインタは通常のポインタへ暗黙の型変換が可能です。ただし、ポインタ型からGCポインタ型への型変換は許可されていません。

また、ＧＣポインタ型はポインタの加算や減算は出来ません。

```c++
class MyClass {};
MyClass^  m = new MyClass();
MyClass*  a = m;    // OK
MyClass^  b = a;    // NG
```

# 配列

passionでは配列も参照カウンタで管理されたオブジェクトです。

```c++
int[] a = new int[100];
int   s = a.size();
int*  b = a.data();
for (int i = 0; i < s; ++i)
{
    *b++ = i;
}

```

c/c++ライクな配列の場合は型側ではなくシンボル側に指定子を書きます。

```c++
int   a[100];
int   s = a.size(); // NG
int*  b = a;
```

# クラスと構造体

passionではクラスと構造体を明確に分けて扱います。

| 項目          | class            | struct     |
| ------------- | ---------------- | ---------- |
| new           | GCポインタを生成 | 使用不可能 |
| placement new | 不可能           | 可能       |

```c++
struct MyStruct {};

MyStruct a;
MyStruct* b = &a;
MyStruct^ c = new MtStryct(); // NG
```

```c++
class MyClass {};
MyClass a;   // NG
MyClass^ b = new MyClass();
MyClass* c = b;
```



# シグネチャとマングリング（name mangling）

passionではc++のような複雑なマンぐリングは行いません。代わりに関数シンボルは名前とシグネチャに展開されます。これはJava(TM)に似ています。ただし、Javaのシグネチャと異なり基本型の名前もプログラムコードの見た目と同じように展開されます。

```c++
int Name1::Name2::FunctionName(Name3::Name4::Name5 param1, int param2, int16_t param2)
```

という関数があった場合これは次のようなシグネチャに展開されます。

```c++
Name1::Name2::FunctionName(Name3::Name4::Name5,int,int16_t)int
```

# 演算子とオペレータ

| 演算子                            | 名称                                        | 対応するメンバ関数            |
| --------------------------------- | ------------------------------------------- | ----------------------------- |
| * cast-expression                 | 単項間接演算子(Indirection)                 | TYPE& operator * ()           |
| & cast-expression                 | 単項アドレス演算子(Address-of)              | なし                          |
| expression -> *expression         | メンバーへのポインター演算子(Member Access) | TYPE operator -> ()           |
| expression . *expression          | メンバーへのポインター演算子(Member Access) | なし                          |
| postfix-expression [ expression ] | 添字演算子(Subscript)                       | TYPE& operator [] (int index) |

#  プロトタイプ宣言

コンパイラはプログラムをコンパイルする際に２回に分けて処理を行います。これはいわゆる２パスと呼ばれます。１回目の処理ではクラスや関数、メンバ関数やメンバ変数と言った宣言部分の解析を行います。２回目の処理では関数内部の処理部分の解析とコード生成を行います。

１回目の処理ではクラスや構造体、関数の引数の大きさの計算とシンボルの確定を行います。