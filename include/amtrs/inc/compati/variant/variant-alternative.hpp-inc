/*-
 * Copyright (c) 2017 Isao Shibuya
 * Released under the MIT license
 * http://opensource.org/licenses/mit-license.php 
 */
template<std::size_t I, class>
struct	variant_alternative;		// Prototype.


template<size_t I, class... Types>
struct	variant_alternative<I, variant<Types...>>
{
	using	type	= typename std::tuple_element<I, std::tuple<Types...>>::type;
};


template<size_t I, class VariantT>
struct	variant_alternative<I, const VariantT>
{
	using	type	= typename std::add_const<variant_alternative<I, VariantT>>::type;
};


template<size_t I, class VariantT>
struct	variant_alternative<I, volatile VariantT>
{
	using	type	= typename std::add_volatile<variant_alternative<I, VariantT>>::type;
};

template <size_t I, class VariantT>
struct	variant_alternative<I, const volatile VariantT>
{
	using	type	= typename std::add_cv<variant_alternative<I, VariantT>>::type;
};


// ============================================================================
//!	@brief	VariantTで指定する variant の I 番目の型を示す。
// ----------------------------------------------------------------------------
//!	variant_alternative_t<3, variant<int, short, long, double>> == double
// ----------------------------------------------------------------------------
template <size_t I, class VariantT>
using	variant_alternative_t	= typename variant_alternative<I, VariantT>::type;

